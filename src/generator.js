// Generated by CoffeeScript 1.12.3
(function() {
  'use strict';
  var bf, findHoles, findValidTiles, generate, getNeighbors, intersect, randInt, retry, select,
    slice = [].slice;

  randInt = Util.randInt, select = Util.select, intersect = Util.intersect;

  findValidTiles = function(board, position) {
    var down, left, right, subsets, up;
    up = board.isInside(position.up()) ? board.get(position.up()) : null;
    down = board.isInside(position.down()) ? board.get(position.down()) : null;
    left = board.isInside(position.left()) ? board.get(position.left()) : null;
    right = board.isInside(position.right()) ? board.get(position.right()) : null;
    subsets = [up != null ? up.neighbors.down : void 0, down != null ? down.neighbors.up : void 0, left != null ? left.neighbors.right : void 0, right != null ? right.neighbors.left : void 0].filter(function(subset) {
      return (subset != null) && subset.length > 0;
    });
    return intersect.apply(null, subsets);
  };

  getNeighbors = function(board, position) {
    var neighbors;
    neighbors = [];
    if (position.x > 0) {
      neighbors.push(position.left());
    }
    if (position.y > 0) {
      neighbors.push(position.up());
    }
    if (position.x < board.size.x - 1) {
      neighbors.push(position.right());
    }
    if (position.y < board.size.y - 1) {
      neighbors.push(position.down());
    }
    return neighbors;
  };

  bf = function(board, start) {
    var candidates, k, len, neighbor, neighbors, position, queue, tries, triesMax;
    queue = slice.call(start);
    tries = 0;
    triesMax = 1000;
    while (tries < triesMax && queue.length > 0) {
      tries++;
      position = queue.shift();
      neighbors = getNeighbors(board, position);
      for (k = 0, len = neighbors.length; k < len; k++) {
        neighbor = neighbors[k];
        if ((board.get(neighbor)) == null) {
          candidates = findValidTiles(board, neighbor);
          queue.push(neighbor);
          board.set(neighbor, select(candidates));
        }
      }
    }
    if (tries >= triesMax) {
      console.log('bf gave up');
    }
  };

  findHoles = function(board) {
    var holes, i, j, k, l, position, ref, ref1;
    holes = [];
    for (i = k = 0, ref = board.size.x; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      for (j = l = 0, ref1 = board.size.y; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
        position = Vec2.make(i, j);
        if ((board.get(position)) == null) {
          holes.push(position);
        }
      }
    }
    return holes;
  };

  retry = function(board) {
    var holes, recycleBin;
    recycleBin = [];
    holes = findHoles(board);
    if (holes.length === 0) {
      return;
    }
    holes.forEach(function(hole) {
      var neighbors;
      neighbors = (getNeighbors(board, hole)).filter(function(neighbor) {
        return (board.get(neighbor)) != null;
      });
      neighbors.forEach(function(neighbor) {
        return board.set(neighbor, null);
      });
      recycleBin.push.apply(recycleBin, neighbors);
    });
    bf(board, recycleBin);
  };

  generate = function(size, tileset) {
    var board, i, k;
    board = Board.make(size);
    board.set(Vec2.make(0, 0), tileset.get('t0-0'));
    bf(board, [Vec2.make(0, 0)]);
    for (i = k = 0; k < 3; i = ++k) {
      retry(board);
    }
    return board;
  };

  if (window.Generator == null) {
    window.Generator = {};
  }

  Object.assign(window.Generator, {
    generate: generate
  });

}).call(this);
